
import org.apache.spark.mllib.tree.DecisionTree\r\nimport org.apache.spark.mllib.tree.model.DecisionTreeModel\r\nimport org.apache.spark.mllib.util.MLUtils\r\nimport org.apache.spark.mllib.tree.RandomForest\r\nimport org.apache.spark.mllib.tree.model.RandomForestModel\r\nimport scala.util.Try\r\n\r\n// Load and parse the data file.\r\nval data = MLUtils.loadLibSVMFile(sc, \"/datasets/irisLibSVM.data\")\r\n\r\n// Split the data into training and test sets (30% held out for testing)\r\nval splits = data.randomSplit(Array(0.7, 0.3))\r\nval (trainingData, testData) = (splits(0), splits(1))\r\n\r\n// Train a DecisionTree model.\r\nval numClasses = 4\r\nval categoricalFeaturesInfo = Map[Int, Int]()\r\nval impurity = \"gini\"\r\nval maxDepth = 5\r\nval maxBins = 32\r\nval numTrees = 3 // Use more in practice.\r\nval featureSubsetStrategy = \"auto\" // Let the algorithm choose.\r\n\r\nval model = RandomForest.trainClassifier(trainingData, numClasses, categoricalFeaturesInfo, numTrees, featureSubsetStrategy, impurity, maxDepth, maxBins)\r\n\r\n// Evaluate model on test instances and compute test error\r\nval labelAndPreds = testData.map { point =>\r\n  val prediction = model.predict(point.features)\r\n  (point.label, prediction)\r\n}\r\n\r\nval testErr = labelAndPreds.filter(r => r._1 != r._2).count().toDouble / testData.count()\r\nprintln(\"Test Error = \" + testErr)\r\n\r\n//Evaluate the effectiveness of classifier\r\nimport org.apache.spark.mllib.evaluation.MulticlassMetrics\r\n\r\nval metrics = new MulticlassMetrics(labelAndPreds.map(x => (x._1, x._2)))\r\nprintln(metrics.confusionMatrix)\r\n\r\n//Let’s look at the precision of the classifier—i.e. how many predictions it gets right.\r\nmetrics.precision\r\n\r\nprintln(\"Learned classification tree model:\\n\" + model.toDebugString)\r\n\r\n//Save and load model\r\nTry[Unit] {model.save(sc, \"/models/irisModel\")}\r\n"

import org.apache.spark.mllib.linalg.Vector\nimport org.apache.spark.mllib.regression.LabeledPoint\nimport org.apache.spark.mllib.linalg.Vectors\n\nval v = Vectors.dense(6.5, 3.2, 5.1, 2) // should be 3.0\n//val v = Vectors.dense(6.1,2.8,4.0,1.3) // should be 3.0\nval predictionClass = model.predict(v)
